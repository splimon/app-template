# Database Layer (`src/lib/db`)

This directory contains the core database infrastructure for the application, built on [Kysely](https://kysely.dev/) - a type-safe SQL query builder for TypeScript.

## Overview

The database layer provides:
- **Type-safe database queries** with full TypeScript support
- **Connection pooling** with automatic retry logic
- **Schema migrations** for version-controlled database changes
- **Auto-generated types** that stay in sync with your database schema

## Structure

```
src/lib/db/
├── kysely/           # Kysely configuration & drivers
│   ├── client.ts     # Database client singleton
│   └── driver.ts     # Custom retry driver for connection resilience
├── migrations/       # SQL migration files
│   ├── 000001_create_initial_tables.up.sql
│   ├── 000001_create_initial_tables.down.sql
│   └── ...
└── types.ts          # Auto-generated TypeScript types from schema via kysely-codegen
```

## Key Components

### `kysely/client.ts`
Exports the main database client (`db`) and connection pool (`pool`). Key features:

- **Singleton Pattern**: Ensures only one database connection pool exists across the application
- **Connection Pooling**: Configured with sensible defaults (max: 5 connections, min: 1)
- **Environment-aware**: Automatically uses `DATABASE_URL` from environment variables
- **Development Monitoring**: Logs connection activity in development mode

**Usage:**
```typescript
import { db } from '@/lib/db/kysely/client';

// Type-safe queries
const users = await db.selectFrom('users').selectAll().execute();
```

### `kysely/driver.ts`
Custom `RetryDriver` implementation that wraps the PostgreSQL driver with automatic retry logic.

**Features:**
- Retries transient errors (connection timeouts, resets, etc.)
- Exponential backoff strategy (100ms → 2000ms)
- Configurable retry attempts (default: 3)
- Only retries on specific error codes (connection issues, not business logic errors)

**Why it matters:** In distributed environments or during deployment, transient connection issues are common. This driver makes your application more resilient by automatically recovering from temporary database unavailability.

### `types.ts`
Auto-generated TypeScript interfaces that mirror your database schema.

**Generated by:** `kysely-codegen` (do not edit manually)

**What it provides:**
- Type definitions for all tables (Users, Sessions, Orgs, Members, etc.)
- Column types with proper TypeScript mappings
- Enum types (Role, Sysrole)
- The main `DB` interface used throughout the application

### `migrations/`
SQL migration files that define your database schema evolution.

**Naming convention:** `XXXXXX_description.{up|down}.sql`
- `up.sql`: Applies the migration (creates tables, adds columns, etc.)
- `down.sql`: Reverses the migration (for rollbacks)

**Current schema:**
- **users**: User accounts with authentication
- **sessions**: Session management for logged-in users
- **login_attempts**: Security audit trail
- **orgs**: Organizations for multi-tenancy
- **members**: User-organization relationships with roles

## How It's Incorporated

### 1. Type Safety Throughout the Stack
```typescript
// The DB type from types.ts provides autocomplete and type checking
import { db } from '@/lib/db/kysely/client';

// ✅ Type-safe: TypeScript knows all columns
const user = await db
  .selectFrom('users')
  .select(['id', 'email', 'username'])
  .where('id', '=', userId)
  .executeTakeFirst();

// ❌ Compile error: TypeScript catches typos
const user = await db.selectFrom('userz') // Error: Table 'userz' doesn't exist
```

### 2. Connection Management
The singleton pattern ensures:
- No duplicate connection pools in serverless environments
- Proper connection reuse across requests
- Automatic cleanup of idle connections

### 3. Schema Evolution
Migrations are the source of truth for your database schema:
1. Write a migration file (`.up.sql` and `.down.sql`)
2. Run migrations to apply changes
3. Regenerate types with `kysely-codegen`
4. TypeScript immediately reflects the new schema

## Common Operations

### Querying
```typescript
import { db } from '@/lib/db/kysely/client';

// Select with filters
const activeUsers = await db
  .selectFrom('users')
  .where('system_role', '=', 'user')
  .selectAll()
  .execute();

// Joins
const userOrgs = await db
  .selectFrom('members')
  .innerJoin('orgs', 'orgs.id', 'members.org_id')
  .where('members.user_id', '=', userId)
  .select(['orgs.name', 'orgs.slug', 'members.member_role'])
  .execute();
```

### Inserting
```typescript
const newUser = await db
  .insertInto('users')
  .values({
    username: 'john_doe',
    email: 'john@example.com',
    password_hash: hashedPassword,
  })
  .returningAll()
  .executeTakeFirstOrThrow();
```

### Transactions
```typescript
await db.transaction().execute(async (trx) => {
  const user = await trx
    .insertInto('users')
    .values({ /* ... */ })
    .returningAll()
    .executeTakeFirstOrThrow();

  await trx
    .insertInto('sessions')
    .values({ user_id: user.id, /* ... */ })
    .execute();
});
```

## Regenerating Types

After creating or modifying migrations:

```bash
# Run migrations
pnpm migrate:up

# Regenerate TypeScript types with Kysely Codegen
pnpm codegen
```

This keeps `types.ts` in sync with your database schema.

## Environment Variables

Required in `.env`:
```
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
```

## Learn More

- [Kysely Documentation](https://kysely.dev/)
- [kysely-codegen](https://github.com/RobinBlomberg/kysely-codegen)
- [node-postgres (pg)](https://node-postgres.com/)
